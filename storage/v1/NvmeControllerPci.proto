//------------------------------------------------------------------------------
// {C} Copyright 2022 Pensando Systems Inc. All rights reserved
//
// NVMe PCI controller proto API specification
//------------------------------------------------------------------------------

syntax = "proto3";
package opi.storage.v1;
option go_package = "github.com/opiproject/opi-api/storage/proto";
import "CommonTypes.proto";

service NvmeControllerSvc {
  // Instantiate a new controller on the given PCI-ID
  rpc NvmeControllerCreate (NvmeControllerCreateRequest) returns (NvmeControllerCreateResponse) {}
  // Enable a namespace attached to the controller
  rpc NvmeControllerEnableNs (NvmeControllerEnableNsRequest) returns (NvmeControllerEnableNsResponse) {}
  // Disable a namespace attached to the controller
  rpc NvmeControllerDisableNs (NvmeControllerDisableNsRequest) returns (NvmeControllerDisableNsResponse) {}
  // Get controller information
  rpc NvmeControllerGet (NvmeControllerGetRequest) returns (NvmeControllerGetResponse) {}
  // Delete a controller
  rpc NvmeControllerDelete (NvmeControllerDeleteRequest) returns (NvmeControllerDeleteResponse) {}
}

enum NvmeControllerConstants {
  NSV_CTRLR_CONST_NONE    = 0;
  // maximum allowed controller serial number string length
  NSV_CTRLR_SERIAL_NO_LEN = 20;
  // maximum allowed controller model number string length
  NSV_CTRLR_MODEL_NO_LEN  = 40;
  // maximum allowed firmware revision string length
  NSV_CTRLR_FW_REV_LEN    = 8;
}

// Identity of the NVMe PCIe controller as seen by the host
// (baremetal or VirtualMachine)
message NvmeControllerIdentity {
  // (mandatory) NVMe controller ID Range: 0 to 65536.
  // Must not be reused under the same subsystem
  uint32 nvme_controller_id  = 1;
  // (mandatory) Serial Number must not exceed 'NSV_CTRLR_SERIAL_NO_LEN' bytes
  string serial_number      = 2;
  // (mandatory) Model Number, must not exceed 'NSV_CTRLR_MODEL_NO_LEN' bytes
  string model_number       = 3;
  // (mandatory) Firmware revision, must not exceed 'NSV_CTRLR_FW_REV_LEN'
  string firmware_revision  = 4;
  // (mandatory) FRU global identfier, 16bytes opaque identity for the unit
  bytes  fru_guid           = 5;
}

// NvmeController create specification
message NvmeControllerSpec {
   // NvmeController object key (mandatory)
  types.ObjectKey       nvme_controller_key  = 1;
  // (mandatory) NVMe subsystem NQN to which the controller belongs
  // Refer to the NQN format in the NVMe base specifications, must not
  // exceed 'NSV_NVME_NQN_LEN' bytes
  bytes                 subsystem_nqn      = 2;
  // (mandatory) DSC PCI ID for the controller, device numbering starts for 0.
  // Eg. PF-0, VF1 = (bus = 0, device = 0, function = 0, Virtual Function = 1)
  // Eg. PF-3, VF4 = (bus = 0, device = 3, function = 0, Virtual Function = 4)
  types.NvmeControllerPciId pci_id         = 3;
  // (optional) Maximum Number of namespaces that will be provisioned under
  // the controller.
  // if set to 0, default provision for the device specified in
  // the DSC PCI configuration json file is used.
  // Must not exceed the maximum value configured for the device
  uint32                num_namespace      = 4;
  // (optional) Maximum host IO queue pairs allowed, value will default to
  // limits in PCI device configuration if set to 0 or more than max permitted
  // by hardware configuration
  uint32                max_io_queue_pairs   = 5;
  // (mandatory) Identity of the controller
  NvmeControllerIdentity    identity      = 6;
}

// Status reported in read operation
message NvmeControllerStatus {
  bool   host_active = 1; // Device is in use by host nvme driver
}

// Statistics reported in read operation
message NvmeControllerStats {
}

// NvmeController object information reported in read operation
message NvmeController {
  NvmeControllerSpec   spec   = 1; // specification
  NvmeControllerStatus status = 2; // status
  NvmeControllerStats  stats  = 3; // stats
}

// Creating a controller configuration instantiates a virtual NVMe PCIe
// controller object at the given PCI-ID (bus/device/function/virtual-function).
// All admin commands are responded with error until the creation of the
// controller and the controller cannot be used by the host driver of
// admin or IO operations.
// Post controller creation, namespace objects can be instantiated under the
// controller.
message NvmeControllerCreateRequest {
  NvmeControllerSpec spec = 1; // controller object specification
}

// controller create response
message NvmeControllerCreateResponse {
  types.ApiStatus  api_status = 1;
}

message NvmeControllerGetRequest {
  // controller key of interest
  types.ObjectKey nvme_controller_key = 1;
}

// controller get
message NvmeControllerGetResponse {
  // overall status of the get operation
  types.ApiStatus  api_status = 1;
  // controller object information
  NvmeController response  = 2;
}

// delete controller request
message NvmeControllerDeleteRequest {
  types.ObjectKey nvme_controller_key = 1; // controller object key
}

// delete controller response
message NvmeControllerDeleteResponse {
  types.ApiStatus  api_status = 1;
}

// namespace enable request
message NvmeControllerEnableNsRequest {
  types.ObjectKey namespace_key = 1; // namespace object key
}
// namespace enable response
message NvmeControllerEnableNsResponse {
  types.ApiStatus  api_status = 1;
}

// namespace disable request
message NvmeControllerDisableNsRequest {
  types.ObjectKey namespace_key = 1; // namespace object key
}

// namespace disable response
message NvmeControllerDisableNsResponse {
  types.ApiStatus  api_status = 1;
}
