//------------------------------------------------------------------------------
// {C} Copyright 2022 Pensando Systems Inc. All rights reserved
//
// Protobuf specification for NVMe namespace service
//------------------------------------------------------------------------------

syntax = "proto3";
package opi.storage.v1;
option go_package = "github.com/opiproject/opi-api/storage/proto";
import "CommonTypes.proto";

service NvmeNamespacePciSvc {
  rpc NvmeNamespacePciCreate (NvmeNamespacePciCreateRequest) returns (NvmeNamespacePciCreateResponse) {}
  rpc NvmeNamespacePciGet (NvmeNamespacePciGetRequest) returns (NvmeNamespacePciGetResponse) {}
  rpc NvmeNamespacePciDelete (NvmeNamespacePciDeleteRequest) returns (NvmeNamespacePciDeleteResponse) {}
  rpc NvmeNamespacePciUpdate (NvmeNamespacePciUpdateRequest) returns (NvmeNamespacePciUpdateResponse) {}
}

message NvmeNamespacePciParams {
  // (mandatory) NVMe NSID of the namespace in the backend target subsystem
  // hosting this namespace.
  uint32             tgt_nsid             = 1;
  // (mandatory) Size/Capacity of the namespace in blocks, size in bytes will
  // be BlockSize x NumBlocks.
  uint64             num_blocks           = 2;
  // (optional) Post path failure wait interval in milliseconds before
  // attempting to create association/IO queues on the failed path.
  // If multiple namespaces share the same path, then the value provided in the
  // first namespace in the share group will be used.
  uint32             retry_interval       = 3;
  // (optional) flag to control when backend session connection is established.
  // 1:  auto connect backend session on namespace enable. backend IO
  // connections are created irrespective of state of the frontend controller
  // object i.e enabled/disabled by the host driver.
  // 0: connect backend session only after controller is enabled by host
  // driver.
  bool               auto_connect         = 4;
  // (optional) Optimal write size hint to host driver. Host IO stack may use
  // this to regulate IO size. Must be a multiple of the preferred write
  // granularity. Must not exceed the controller maximum IO size value
  // configured in the nvme agent config file.
  uint32             optimal_write_size    = 5;
  // (optional) Preferred write granularity hint to the host driver. Host IO
  // stack may use this to align IO sizes to the write granularity for
  // optimum performance.
  uint32             pref_write_granularity= 6;
}

// namespace specification
message NvmeNamespacePciSpec {
  // (mandatory) key for the namespace object.
  types.ObjectKey    nvme_namespace_pci_key = 1;
  // (mandatory) key of the PCIe controller object that will host this
  // namespace.
  types.ObjectKey    controller_key       = 2;
  // (mandatory) Encryption key for the data at rest encryption.
  types.ObjectKey    crypto_key_key        = 3;
  // (optional) Cluster object to which the corresponding backend namespace
  // belongs. If not provided, then namespace will be assigned to default
  // cluster.
  types.ObjectKey    cluster_key          = 4;
  // (mandatory) Initiator device for the namespace, corresponding initiator
  // device NQN.  Must have access permission to the backend namespace in the
  // target subsystem.
  types.ObjectKey    initiator_device_key  = 5;
  // (mandatory) Backaned target subsystem that is hosting namespace.
  bytes              tgt_subsys_nqn        = 6;
  // (mandatory) if Guid is not provided.
  // (optional) if Fuid is provided.
  // 64bit Extended unique identifier for the namespace.
  fixed64            eui                 = 7;
  // (mandatory) If Eui is not provided.
  // (optional) If Eui is provided.
  // Globally unique identifier for the namespace.
  bytes              guid                = 8;
  // (optional) NSID present to the host by the NVMe PCIe controller.
  // If not provided, then the controller will assign an unused NSID
  // within the max namespace range.
  // Note, if Live Migration support is enabled for the controller, then it
  // recommended that the host nsid is provided by the host agent as auto
  // assignment my result in different NSIDs for the same namespace on
  // migration source and destination controllers.
  uint32             host_nsid            = 9;
  // Block size in bytes, must be power of 2 and must be less than the max
  // io size supported. Typically tested values are 512, and 4k.
  uint32             block_size           = 10;
  // (mandatory) path management type to use for the namespace.
  types.NvmePathMgmtType mgmt_type        = 11;
  // namespace parameters
  NvmeNamespacePciParams    params       = 12;
  // (optional) maximum connections allowed.
  uint32             max_num_connections   = 13;
}

// Namespace  Administrative States
enum NvmeNamespacePciState {
  NAMESPACE_STATE_DISABLED    = 0;  // namespace disabled state
  NAMESPACE_STATE_ENABLED     = 1;  // namespace enabled state
  NAMESPACE_STATE_DELETING    = 2;  // namespace deleting state
}

// Namespace Operational States
enum NvmeNamespacePciOperState {
  NAMESPACE_OPER_STATE_ONLINE = 0;  // namespace is online
  NAMESPACE_OPER_STATE_OFFLINE= 1;  // namespace is offline
}

// namespace status
message NvmeNamespacePciStatus {
  // config state of the namespace object, (enabled, disable, deleting)
  NvmeNamespacePciState      nvme_namespace_pci_state       = 1;
  // Operational state of the namespace object, (connected, disconnected)
  NvmeNamespacePciOperState  nvme_namespace_pci_oper_state   = 2;
}

// namespace stats
message NvmeNamespacePciStats {
}

// namespace object
message NvmeNamespacePci {
  NvmeNamespacePciSpec   spec   = 1; // namespace specification
  NvmeNamespacePciStatus status = 2; // namespace status
  NvmeNamespacePciStats  stats  = 3; // namespace stats
}

// create request
message NvmeNamespacePciCreateRequest {
  NvmeNamespacePciSpec spec = 1; // namespace specification
}

//
message NvmeNamespacePciCreateResponse {
  types.ApiStatus api_status = 1; // status code
}

// get request
message NvmeNamespacePciGetRequest {
  types.ObjectKey nvme_namespace_pci_key = 1;
}

// get response
message NvmeNamespacePciGetResponse {
  types.ApiStatus api_status = 1; // status code
  NvmeNamespacePci response    = 2; // response
}

// update request
message NvmeNamespacePciUpdateRequest {
  types.ObjectKey nvme_namespace_pci_key = 1;  // namespace object key
  NvmeNamespacePciParams params       = 2;
}

// update response
message NvmeNamespacePciUpdateResponse {
  types.ApiStatus api_status = 1; // status code
}

// delete request
message NvmeNamespacePciDeleteRequest {
  types.ObjectKey nvme_namespace_pci_key = 1;  // namespace object key
}

// delete response
message NvmeNamespacePciDeleteResponse {
  types.ApiStatus api_status = 1; // status code
}

